<!doctype html>
<meta charset="utf-8" />
<title>Trevor Guest Exploration — Network</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --sidebar-bg: #0f172a;   /* slate-900 */
    --sidebar-fg: #e5e7eb;   /* gray-200 */
    --sidebar-muted: #94a3b8;/* slate-400 */
    --accent: #38bdf8;       /* sky-400 */
    --guest: #01fccb;       /* light blue */
    --show:  #414066;        /* orange */
    --border: #e5e7eb;
    --controls-width: 400px;
  }
  html, body { margin:0; height:100%; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }

  /* Two-column responsive layout */
  .layout {
    display: grid;
    grid-template-columns: 35% 65%;
    min-height: 100vh;
  }
  @media (max-width: 980px) {
    .layout { grid-template-columns: 1fr; }
  }

  /* Sidebar */
  .sidebar {
    background: var(--sidebar-bg);
    color: var(--sidebar-fg);
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 18px;
  }
  .sidebar > *:first-child { 
  margin-top: 0;               /* ensure the heading can’t escape upward */
}
  .sidebar h1 {
    margin: 0 0 6px 0;
    font-size: 22px;
    line-height: 1.2;
    color: #fff;
  }
  .sidebar h2 {
    margin: 8px 0 4px 0;
    font-size: 14px;
    text-transform: uppercase;
    letter-spacing: .06em;
    color: var(--sidebar-muted);
  }
  .sidebar p, .sidebar li {
    margin: 0;
    color: var(--sidebar-fg);
    line-height: 1.5;
    font-size: 14px;
  }
  .sidebar ul { 
  margin: 0 0 12px 1.1rem;     /* no top margin; modest bottom margin; sensible indent */
  padding-left: 0; 
}
.sidebar h2 + ul {
  margin-top: 4px;             /* kill the big top margin on first sibling */
}
.sidebar li { 
  margin: 4px 0;               /* tighter spacing between bullets */
}
  .sidebar .search-box input {
  width: var(--controls-width);
  max-width: 100%;
}
  .sidebar a { color: var(--accent); text-decoration: none; }
  .sidebar a:hover { text-decoration: underline; }
  .pill {
    display: flex; align-items: center; gap: 8px;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 999px; padding: 8px 10px;
  }
  .legend { display:flex; gap:12px; align-items:center; }
  .swatch { width:12px; height:12px; border-radius:3px; display:inline-block; }

  .search-box input {
    width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.06); color: #fff; outline: none;
  }
  .search-box input::placeholder { color: rgba(255,255,255,0.6); }

  /* Main graph area */
  .main {
    position: relative;
    background: #fff;
    overflow: hidden;
  }
  #graph {
    position: absolute; inset: 0;
  }

  .tooltip {
    position: fixed; z-index: 10; display: none; pointer-events: none;
    background: rgba(255,255,255,0.97); border: 1px solid #ddd; border-radius: 6px;
    padding: 6px 8px; font-size: 12px; color: #111;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    max-width: 320px;
  }
  .label { font-size: 10px; pointer-events: none; fill: #333; }

  /* If you can edit <body>, use this: */
html, body { height: 100%; margin: 0; }
body { overflow: hidden; }                 /* only the sidebar scrolls */

/* If you can't touch <body>, use this fallback instead: */
/* html { overflow: hidden; } */

.layout {
  /* fixed-width, centered shell */
  width: auto;                           /* pick your width: 1280/1366/1440 */
  max-width: 100vw;                        /* avoid horiz scroll on small screens */
  margin: 0 auto;
  height: 100vh;                           /* lock to viewport height */
  display: grid;
  grid-template-columns: 35% 65%;
}

.sidebar {
  height: 100%;
  overflow-y: auto;                        /* <-- only this panel scrolls */
  -webkit-overflow-scrolling: touch;
}

.main {
  position: relative;
  height: 100%;
  overflow: hidden;                        /* graph handles zoom/pan internally */
}

#graph { position: absolute; inset: 0; }


</style>

<div class="layout">
  <!-- LEFT PANEL (35%) -->
  <aside class="sidebar">
    <h1>Who else do Trevor Noah's guests speak to?</h1>
    <h2>Built by <a href="https://www.instagram.com/foofoo2you/" target="_blank" rel="noopener">Foo</a></h2>

    <h2>What you’re looking at</h2>
<p>
  This is an interactive network diagram of <strong>Trevor Noah’s podcast guests</strong> and the <strong>other podcasts</strong> they’ve appeared on:
  <li>Each dot is a person or a show; a line connects a guest to a podcast they’ve been on.</li>
  <li>The closer any two dots are, the more strongly they're connected to the same other dots (i.e. guests who share the same podcasts cluster together).</li>
  <li>Guest dots get bigger the more different shows they’re linked to in this dataset.</li>
  <li>To keep the picture focused, this view only includes podcasts where at least two of Trevor’s guests have shown up.</li>
</p>

    <div class="pill legend">
      <span class="swatch" style="background:var(--guest)"></span> Guests
      <span class="swatch" style="background:var(--show)"></span> Podcasts
    </div>

    <div class="search-box">
      <input id="search" type="text" placeholder="Search guest or podcast…" />
    </div>

<h2>Why this could be interesting</h2>
<ul>
  <li>Discover future guests: see which other podcasts overlap with your topics and guests, which could be useful in understanding who else these podcasts are, or are not, speaking to</li>
  <li>Curate future topics: explore how seemingly different guests cluster around one another to understand how these episodes might connect</li>
  <li>Understand the broader landscape: the network could spark ideas or inspiration by presenting a different perspective on the ways in which these guests fit into a larger cultural discourse</li>
</ul>

<h2>How this was built</h2>
<ul>
  <li>Queried the Spotify Web API for episodes and show metadata.</li>
  <li>Pulled guest names from episode titles (Python, regex) and hand-checked any misses.</li>
  <li>Searched Spotify for each guest’s other podcast appearances and fetched show details.</li>
  <li>Created one link per guest–show pair (no duplicates) and filtered to shows with ≥ 2 Trevor guests.</li>
</ul>

<h2>How to use it</h2>
<ul>
  <li><strong>Hover</strong> a dot to see its connections (those links brighten).</li>
  <li><strong>Click</strong> a dot to focus on its neighborhood; everything else fades to grey.</li>
  <li><strong>Search</strong> for names in the box above; clear the search to reset.</li>
  <li><strong>Zoom &amp; pan</strong> with your mouse or trackpad.</li>
  <li><strong>Open links</strong>: Ctrl/Cmd-click a node (if it has a URL).</li>
</ul>

<h2>Notes &amp; caveats</h2>
<ul>
  <li>Spotify covers a lot, but not the entire podcast universe—some appearances won’t be here.</li>
  <li>Common names can collide; obvious false positives were cleaned up manually.</li>
  <li>This is about <em>connections</em> (who appears where), not transcripts or content.</li>
</ul>

  </aside>

  <!-- RIGHT PANEL (65%) -->
  <main class="main">
    <div id="graph"></div>
    <div id="tooltip" class="tooltip"></div>
  </main>
</div>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
(async function () {
  // ---------- Data ----------
  const dataPath = "data";
  const nodes = await d3.csv(`${dataPath}/nodes.csv`, d => ({
    id: d.id,
    label: d.label,
    group: (d.group || "").toLowerCase(),  // "guest" | "podcast"
    url: d.url || null,
    publisher: d.publisher || null
  }));
  const linksAll = await d3.csv(`${dataPath}/links.csv`, d => ({
    source: d.source,
    target: d.target,
    value: +d.value || 1
  }));

  // Keep only links that reference existing nodes
  const nodeById = new Map(nodes.map(n => [n.id, n]));
  const links = linksAll.filter(l => nodeById.has(l.source) && nodeById.has(l.target));

  // Degree for sizing guests only
  const degree = new Map(nodes.map(n => [n.id, 0]));
  for (const l of links) {
    degree.set(l.source, (degree.get(l.source) || 0) + 1);
    degree.set(l.target, (degree.get(l.target) || 0) + 1);
  }
  const guestDegs = nodes.filter(n => n.group === "guest").map(n => degree.get(n.id) || 0);
  const size = d3.scaleSqrt().domain(d3.extent(guestDegs.length ? guestDegs : [1,1])).range([4, 18]);
  const SHOW_R = 6;
  const nodeRadius = d => d.group === "podcast" ? SHOW_R : size(degree.get(d.id) || 1);

  // Neighbor index (used for selection + greyscale)
  const neighbors = new Map(nodes.map(n => [n.id, new Set()]));
  for (const l of links) { neighbors.get(l.source).add(l.target); neighbors.get(l.target).add(l.source); }
  const isNeighbor = (a,b) => a === b || neighbors.get(a)?.has(b);

  // ---------- Sizing ----------
  const mainEl = document.getElementById("graph").parentElement; // .main
  const rect = mainEl.getBoundingClientRect();
  let width = rect.width, height = rect.height || Math.max(700, window.innerHeight);

  // ---------- SVG ----------
  const svg = d3.select("#graph").append("svg")
    .attr("viewBox", [0, 0, width, height])
    .style("width","100%").style("height","100%");
  const container = svg.append("g");

  // Zoom/pan
  const zoom = d3.zoom()
  .scaleExtent([0.2, 8]) // allow zooming out below 1
  .on("zoom", (ev) => container.attr("transform", ev.transform));

    svg.call(zoom);

        // Start zoomed out at, say, 0.75x, centered in the viewport
    const initialScale = 0.4;
    const tx = (width - width * initialScale) / 2;
    const ty = (height - height * initialScale) / 2;

    svg.call(
    zoom.transform,
    d3.zoomIdentity.translate(tx, ty).scale(initialScale)
    );

  // Greyscale filter (for non-neighbors on selection)
  const defs = svg.append("defs");
  defs.append("filter").attr("id","desaturate").append("feColorMatrix")
    .attr("type","saturate").attr("values","0");

  // Layers
  const linkLayer = container.append("g").attr("stroke","#999").attr("stroke-opacity",0.6);
  const nodeLayer = container.append("g");
  const labelLayer = container.append("g").attr("pointer-events","none").attr("font-size",10).attr("font-family","sans-serif");

  // Tooltip
  const tooltip = d3.select("#tooltip");
  const showTip = (html, ev) => tooltip.style("display","block").html(html).style("left", (ev.clientX+12)+"px").style("top",(ev.clientY+12)+"px");
  const hideTip = () => tooltip.style("display","none");

  // Selections
  const linkSel = linkLayer.selectAll("line").data(links, d => d.source + "→" + d.target).join("line")
    .attr("stroke-width", d => Math.max(1, Math.log((d.value||1) + 1)));
  const nodeSel = nodeLayer.selectAll("circle").data(nodes, d => d.id).join("circle")
    .attr("r", d => nodeRadius(d))
    .attr("fill", d => d.group === "podcast" ? getComputedStyle(document.documentElement).getPropertyValue("--show") : getComputedStyle(document.documentElement).getPropertyValue("--guest"))
    .attr("stroke", "#fff").attr("stroke-width", 1.2)
    .style("cursor", d => d.url ? "pointer" : "default");
  const labelSel = labelLayer.selectAll("text").data(nodes, d => d.id).join("text")
    .attr("class","label").text(d => d.label).attr("opacity",0);

  // Force
  const sim = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d => d.id).distance(120).strength(0.6))
    .force("charge", d3.forceManyBody().strength(-140))
    .force("collision", d3.forceCollide().radius(d => nodeRadius(d) + 6))
    .force("center", d3.forceCenter(width/2, height/2))
    .on("tick", ticked);

  function ticked() {
    linkSel
      .attr("x1", d => d.source.x).attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
    nodeSel
      .attr("cx", d => d.x).attr("cy", d => d.y);
    labelSel
      .attr("x", d => d.x + nodeRadius(d) + 4)
      .attr("y", d => d.y + 3);
  }

  // Hover (kept as your default behavior)
  nodeSel
    .on("mouseenter", (ev, d) => {
      showTip(`<strong>${d.label}</strong>${d.publisher?`<br>${d.publisher}`:""}`, ev);
      linkSel
        .attr("display","none")
        .filter(l => l.source.id === d.id || l.target.id === d.id)
        .attr("display","block");
      nodeSel
        .attr("stroke","#fff")
        .filter(n => n.id === d.id)
        .attr("stroke","#000");
    })
    .on("mousemove", (ev) => tooltip.style("left",(ev.clientX+12)+"px").style("top",(ev.clientY+12)+"px"))
    .on("mouseleave", () => {
      hideTip();
      linkSel.attr("display","block");
      nodeSel.attr("stroke","#fff");
    });

  // Click selection (greyscale non-neighbors) — this matches the behavior you kept
  let selectedId = null;
  function applySelection() {
    if (!selectedId) {
      nodeSel.attr("opacity",1).attr("filter", null);
      linkSel.attr("opacity",0.6).attr("display","block");
      labelSel.attr("opacity",0);
      return;
    }
    nodeSel
      .attr("opacity", n => isNeighbor(selectedId, n.id) ? 1 : 0.2)
      .attr("filter", n => isNeighbor(selectedId, n.id) ? null : "url(#desaturate)");
    linkSel
      .attr("opacity", l => (l.source.id === selectedId || l.target.id === selectedId) ? 0.9 : 0.05)
      .attr("display","block");
    labelSel.attr("opacity", n => isNeighbor(selectedId, n.id) ? 1 : 0);
  }
  function clearSelection(){ selectedId = null; applySelection(); }

  nodeSel.on("click", (ev, d) => {
    ev.stopPropagation();
    // Ctrl/Cmd-click opens URL; normal click toggles selection
    if (ev.ctrlKey || ev.metaKey) { if (d.url) window.open(d.url, "_blank","noopener"); return; }
    // clear search when selecting
    const s = document.getElementById("search"); if (s && s.value) s.value = "";
    selectedId = (selectedId === d.id) ? null : d.id;
    applySelection();
  });

  // Click empty space clears selection
  container.insert("rect", ":first-child")
    .attr("x",0).attr("y",0).attr("width",width).attr("height",height)
    .attr("fill","transparent")
    .on("click", () => clearSelection());

  // Search (dims non-matches; doesn’t disable hover/selection)
  const searchEl = document.getElementById("search");
  function applySearch() {
    const q = (searchEl.value || "").trim().toLowerCase();
    if (!q) { applySelection(); return; } // fall back to selection state
    selectedId = null; // search overrides selection
    const matches = new Set(nodes.filter(n => (n.label||n.id).toLowerCase().includes(q)).map(n => n.id));
    nodeSel.attr("opacity", n => matches.has(n.id) ? 1 : 0.15).attr("filter", null);
    linkSel.attr("opacity", l => (matches.has(l.source.id) || matches.has(l.target.id)) ? 0.9 : 0.05);
    labelSel.attr("opacity", n => matches.has(n.id) ? 1 : 0);
  }
  searchEl.addEventListener("input", applySearch);

  // Handle resize (optional)
  const ro = new ResizeObserver(() => {
    const r = mainEl.getBoundingClientRect();
    width = r.width; height = r.height;
    svg.attr("viewBox", [0,0,width,height]);
    sim.force("center", d3.forceCenter(width/2, height/2)).alpha(0.2).restart();
  });
  ro.observe(mainEl);

  // Expose for debug
  window._graph = { nodes, links, sim };
})();
</script>
